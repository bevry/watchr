// Generated by CoffeeScript 1.3.1

/*
Watchr is used to be nofitied when a change happens to, or within a directory.
You will not be notified what file was changed, or how it was changed.
It will track new files and their changes too, and remove listeners for deleted files appropriatly.

The source code here is written as an experiment of literate programming
Which means you would be able to understand it, without knowing code
*/


(function() {
  var EventEmitter, Watcher, balUtil, debug, fs, watch, watchers,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  balUtil = require('bal-util');

  debug = false;

  watchers = {};

  Watcher = (function(_super) {

    __extends(_Class, _super);

    _Class.prototype.path = null;

    _Class.prototype.isDirectory = null;

    _Class.prototype.stat = null;

    _Class.prototype.fswatcher = null;

    _Class.prototype.children = null;

    _Class.prototype.state = 'pending';

    _Class.prototype.method = null;

    function _Class(options) {
      var applyStat, listener, watcher, _i, _len, _ref,
        _this = this;
      options || (options = {});
      watcher = this;
      this.children = {};
      applyStat = function(stat) {
        _this.stat = stat;
        _this.isDirectory = stat.isDirectory();
        return _this.watch(function(err) {
          return typeof options.next === "function" ? options.next(err, watcher) : void 0;
        });
      };
      this.path = options.path;
      this.options = options;
      if (options.listener) {
        this.listen(options.listener);
      }
      if (options.listeners) {
        _ref = options.listeners;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          this.listen(listener);
        }
      }
      if (options.stat) {
        applyStat(options.stat);
      } else {
        fs.stat(this.path, function(err, stat) {
          if (_this.state === 'closed') {
            return;
          }
          if (err) {
            throw err;
          }
          return applyStat(stat);
        });
      }
    }

    _Class.prototype.listen = function(listener) {
      this.removeListener('changed', listener);
      this.on('changed', listener);
      if (debug) {
        console.log("added a listener: on " + this.path);
      }
      return this;
    };

    _Class.prototype.bubble = function() {
      var args, currentStat, eventName, filename, previousStat;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      eventName = args[0], filename = args[1], currentStat = args[2], previousStat = args[3];
      if (debug) {
        console.log("bubble: " + eventName + ": " + filename + " on " + this.path);
      }
      this.emit('changed', eventName, filename, currentStat, previousStat);
      return this;
    };

    _Class.prototype.changed = function() {
      var args, currentStat, determineTheChange, fileExists, fileFullPath, isTheSame, me, previousStat,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      me = this;
      fileFullPath = this.path;
      currentStat = null;
      previousStat = this.stat;
      fileExists = null;
      if (debug) {
        console.log("watch event triggered on " + this.path);
      }
      isTheSame = function() {
        if ((currentStat != null) && (previousStat != null)) {
          if (currentStat.size === previousStat.size && currentStat.mtime.toString() === previousStat.mtime.toString()) {
            return true;
          }
        }
        return false;
      };
      determineTheChange = function() {
        if (!fileExists) {
          if (debug) {
            console.log('determined unlink:', fileFullPath);
          }
          return _this.emit('changed', 'unlink', fileFullPath, currentStat, previousStat);
        } else {
          if (isTheSame()) {
            if (debug) {
              return console.log("determined same:", fileFullPath);
            }
          } else {
            if (_this.isDirectory) {
              if (isTheSame() === false) {
                return fs.readdir(fileFullPath, function(err, newFileRelativePaths) {
                  if (err) {
                    throw err;
                  }
                  return balUtil.each(newFileRelativePaths, function(newFileRelativePath) {
                    var newFileFullPath;
                    if (_this.children[newFileRelativePath] != null) {

                    } else {
                      newFileFullPath = path.join(fileFullPath, newFileRelativePath);
                      return fs.stat(newFileFullPath, function(err, newFileStat) {
                        if (err) {
                          throw err;
                        }
                        if (debug) {
                          console.log('determined new:', newFileFullPath);
                        }
                        _this.emit('changed', 'new', newFileFullPath, newFileStat, null);
                        return _this.watchChild(newFileFullPath, newFileRelativePath, newFileStat);
                      });
                    }
                  });
                });
              }
            } else {
              if (debug) {
                console.log('determined change:', fileFullPath);
              }
              return _this.emit('changed', 'change', fileFullPath, currentStat, previousStat);
            }
          }
        }
      };
      path.exists(fileFullPath, function(exists) {
        fileExists = exists;
        if (fileExists) {
          return fs.stat(fileFullPath, function(err, stat) {
            if (err) {
              throw err;
            }
            currentStat = stat;
            me.stat = currentStat;
            return determineTheChange();
          });
        } else {
          return determineTheChange();
        }
      });
      return this;
    };

    _Class.prototype.close = function() {
      var childRelativePath, watchr, _ref;
      if (this.state === 'closed') {
        return this;
      }
      if (debug) {
        console.log("close: " + this.path);
      }
      _ref = this.children;
      for (childRelativePath in _ref) {
        if (!__hasProp.call(_ref, childRelativePath)) continue;
        watchr = _ref[childRelativePath];
        this.closeChild(childRelativePath);
      }
      if (this.state !== 'closed') {
        if (this.method === 'watchFile') {
          fs.unwatchFile(this.path);
        } else if (this.method === 'watch' && this.fswatcher) {
          this.fswatcher.close();
          this.fswatcher = null;
        }
        this.state = 'closed';
      }
      if (watchers[this.path] != null) {
        delete watchers[this.path];
      }
      return this;
    };

    _Class.prototype.closeChild = function(fileRelativePath) {
      var watcher;
      watcher = this.children[fileRelativePath];
      if (watcher) {
        watcher.close();
        delete this.children[fileRelativePath];
      }
      return this;
    };

    _Class.prototype.watchChild = function(fileFullPath, fileRelativePath, fileStat, next) {
      var me, options;
      me = this;
      options = this.options;
      return watch({
        path: fileFullPath,
        listener: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return me.bubble.apply(me, args);
        },
        stat: fileStat,
        ignoreHiddenFiles: options.ignoreHiddenFiles,
        ignorePatterns: options.ignorePatterns,
        next: function(err, watcher) {
          if (err) {
            return typeof next === "function" ? next(err) : void 0;
          }
          me.children[fileRelativePath] = watcher;
          return typeof next === "function" ? next() : void 0;
        }
      });
    };

    _Class.prototype.watch = function(next) {
      var me, options, startWatching,
        _this = this;
      me = this;
      options = this.options;
      if (debug) {
        console.log("watch: " + this.path);
      }
      this.close();
      startWatching = function() {
        var tasks;
        tasks = new balUtil.Group(function(err) {
          return typeof next === "function" ? next(err) : void 0;
        });
        tasks.total = 2;
        if (_this.isDirectory) {
          balUtil.scandir({
            path: _this.path,
            ignoreHiddenFiles: options.ignoreHiddenFiles,
            ignorePatterns: options.ignorePatterns,
            recurse: false,
            next: function(err) {
              return tasks.complete(err);
            },
            action: function(fileFullPath, fileRelativePath, nextFile, fileStat) {
              return me.watchChild(fileFullPath, fileRelativePath, fileStat, function(err) {
                return nextFile(err);
              });
            }
          });
        } else {
          tasks.complete();
        }
        try {
          fs.watchFile(_this.path, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return me.changed.apply(me, args);
          });
          _this.method = 'watchFile';
        } catch (err) {
          _this.fswatcher = fs.watch(_this.path, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return me.changed.apply(me, args);
          });
          _this.method = 'watch';
        }
        _this.state = 'active';
        return tasks.complete();
      };
      path.exists(this.path, function(exists) {
        if (!exists) {
          next();
          return this;
        }
        return startWatching();
      });
      return this;
    };

    return _Class;

  })(EventEmitter);

  watch = function() {
    var arg, args, i, k, listener, options, path, watcher, _i, _j, _len, _len1, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    options = {
      listeners: []
    };
    path = null;
    for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
      arg = args[i];
      if (typeof arg === 'string') {
        path = arg;
      } else if (typeof arg === 'object') {
        for (k in arg) {
          options[k] = arg[k];
        }
      } else if (typeof arg === 'function') {
        if (i === args.length - 1 && ((options.listener != null) || ((_ref = options.listeners) != null ? _ref.length : void 0))) {
          options.next = arg;
        } else {
          options.listeners.push(arg);
        }
      } else if (Array.isArray(arg)) {
        for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
          listener = arg[_j];
          options.listeners.push(listener);
        }
      }
    }
    if (path != null) {
      options.path = path;
    }
    path = options.path;
    if (path == null) {
      throw new Error("No path specified");
    }
    if (watchers[path] != null) {
      watcher = watchers[path];
      if (typeof options.next === "function") {
        options.next(null, watcher);
      }
    } else {
      watcher = new Watcher(options);
      watchers[path] = watcher;
    }
    return watcher;
  };

  module.exports = {
    watch: watch,
    Watcher: Watcher
  };

}).call(this);
